<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Physics-Based Three.js Movement with Jumping</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; height: 100%; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #fff;
            font-family: sans-serif;
            z-index: 1;
        }
        #btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            padding: 20px 40px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            z-index: 10;
        }
        #backgroundDim {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 0;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-family: sans-serif;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            background-color: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
        }
        .interactPrompt {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: sans-serif;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 5px;
            display: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="backgroundDim"></div>
    <button id="btn" onclick="startFPS()">Start</button>
    <div id="info">Click the button to start and move around</div>
    <div id="controls">
        Controls:<br>
        W,A,S,D - Move<br>
        SPACE - Jump<br>
        Shift - Sprint<br>
        E - Interact
    </div>
    <div id="crosshair"></div> <!-- Crosshair element -->
    <div class="interactPrompt" id="interactPrompt">Press E to interact</div>
    <div class="interactPrompt" id="goBackPrompt">Press E to go to the next place</div>
    <div class="interactPrompt" id="toForrestPrompt">Press E to go to the next place</div>
    <div class="interactPrompt" id="toPersonalExample">Press E to go to the next place</div>
    <div class="interactPrompt" id="toConclusion">Press E to go to the conclusion</div>
    <div class="interactPrompt" id="finished">🎉 Thanks for participating! References are on classroom. 🎉</div>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/controls/PointerLockControls.js"></script>
    <!-- Add FontLoader and TextGeometry -->
    <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/geometries/TextGeometry.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        let started = false;
        let canStartJump = true;
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

        scene.background = new THREE.Color(0x87ceeb); // Light blue color

        var controls = new THREE.PointerLockControls(camera, document.body);

        // Array to store all collidable objects
        const collidableObjects = [];
        
        console.log("PointerLockControls initialized");
        function startFPS() {
            document.getElementById("btn").style.display = "none"; // Hide the button
            document.getElementById("backgroundDim").style.display = "none"; // Hide the dimmed background
            console.log("FPS started");
            document.getElementById("info").innerHTML = "WASD to move, SPACE to jump, E to interact";
            controls.lock(); // Lock the pointer to start the FPS mode
            started = true;
        }

        // Relock controls when clicked after unlock
        document.addEventListener('click', () => {
            if (started && !controls.isLocked) {
                controls.lock();
            }
        });

        scene.add(controls.getObject());

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // // Create a grid for the ground
        // var gridHelper = new THREE.GridHelper(200, 200);
        // gridHelper.position.y = 0;
        // scene.add(gridHelper);

        const textureLoader = new THREE.TextureLoader();

        // Load the grass texture
        const grassTexture = textureLoader.load('textures/grass.jpg'); // Replace with your texture path

        grassTexture.wrapS = THREE.RepeatWrapping;
        grassTexture.wrapT = THREE.RepeatWrapping;
        grassTexture.repeat.set(100, 100); // Adjust texture repeat (higher values for more repetition)

        const floorGeometry = new THREE.PlaneGeometry(300, 300);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            map: grassTexture, 
            side: THREE.DoubleSide
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // lighting
        const light = new THREE.AmbientLight(0x404040, 1); // Ambient light
        scene.add(light);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 5, 5).normalize();
        scene.add(directionalLight);

        // Load Skybox textures
        const loader = new THREE.CubeTextureLoader();
        loader.setPath('https://raw.githubusercontent.com/Mintype/visual-essay/refs/heads/main/textures/'); // Replace with your skybox textures folder path
        const textureCube = loader.load([
            'px.png', 'nx.png', // Right, Left
            'py.png', 'ny.png', // Top, Bottom
            'pz.png', 'nz.png'  // Front, Back
        ]);
        scene.background = textureCube;


        // Text in sky
        function addSkyText() {
            // Using the FontLoader to load a font
            const fontLoader = new THREE.FontLoader();
            
            // Loading the font (using a common Three.js font)
            fontLoader.load('https://cdn.jsdelivr.net/npm/three@latest/examples/fonts/helvetiker_bold.typeface.json', function(font) {
                // Text geometry parameters
                const textOptions = {
                    font: font,
                    size: 3,          // Size of the text
                    height: 0.8,      // Thickness/depth of the text
                    curveSegments: 12, // Number of points on the curves
                    bevelEnabled: true,
                    bevelThickness: 0.2,
                    bevelSize: 0.1,
                    bevelOffset: 0,
                    bevelSegments: 5
                };
                
                // Create text geometry with the message
                const textGeometry = new THREE.TextGeometry('The Role of Luck in Overcoming Adversity', textOptions);
                
                // Center the text geometry
                textGeometry.computeBoundingBox();
                const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
                textGeometry.translate(-textWidth / 2, -8, 0);
                
                // Create a material for the text - using gradient material for nice effect
                const textMaterial = [
                    // Front face
                    new THREE.MeshPhongMaterial({ color: 0xAAAAAA, specular: 0x555555, shininess: 30 }),
                    // Side faces
                    new THREE.MeshPhongMaterial({ color: 0x888888, specular: 0x222222, shininess: 30 })
                ];
                
                // Create the text mesh
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                
                // Position the text high in the sky, visible from spawn position
                textMesh.position.set(0, 30, -40); // y: height, z: distance in front
                
                // Add subtle rotation for better visibility
                textMesh.rotation.x = Math.PI * 0.1; // Slight tilt for better viewing from below
                
                // Add to scene
                scene.add(textMesh);
                
                // Create a spotlight to highlight the text
                const spotlight = new THREE.SpotLight(0xffffff, 1.5);
                spotlight.position.set(0, 25, -30);
                spotlight.target = textMesh;
                spotlight.angle = Math.PI / 6;
                spotlight.penumbra = 0.1;
                spotlight.distance = 60;
                scene.add(spotlight);
            });
        }
        
        // Call the function to add sky text
        addSkyText();

        // Add pedestal with button and text
        function createPedestalAndButton() {
            const pedestalGroup = new THREE.Group();
            
            // Create pedestal
            const pedestalGeometry = new THREE.CylinderGeometry(0.75, 0.3, 2.75, 32);
            const pedestalMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 }); // Brown color
            const pedestal = new THREE.Mesh(pedestalGeometry, pedestalMaterial);
            pedestalGroup.add(pedestal);
            
            // Add pedestal to collidable objects
            pedestal.userData.isCollidable = true;
            collidableObjects.push(pedestal);
            
            // Create button on top of pedestal
            const buttonGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 32);
            const buttonMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // Red button
            const button = new THREE.Mesh(buttonGeometry, buttonMaterial);
            button.position.y = 1.5;
            button.name = "secretButton"; // Name for raycasting
            pedestalGroup.add(button);
            
            // Add button to collidable objects
            button.userData.isCollidable = true;
            collidableObjects.push(button);
            
            // Add text above button
            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://cdn.jsdelivr.net/npm/three@latest/examples/fonts/helvetiker_regular.typeface.json', function(font) {
                const textOptions = {
                    font: font,
                    size: 0.2,
                    height: 0.05,
                    curveSegments: 12,
                    bevelEnabled: false
                };
                
                const textGeometry = new THREE.TextGeometry('Click me to start!', textOptions);
                textGeometry.computeBoundingBox();
                const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
                textGeometry.translate(-textWidth / 2, 0, 0);
                
                const textMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.set(0, 1.8, 0);
                pedestalGroup.add(textMesh);
            });
            
            // Position the pedestal
            pedestalGroup.position.set(0, 0, -10); // 10 units in front of spawn
            scene.add(pedestalGroup);
            
            return button;
        }

        function createTextWall(fontsize, stareee, essayText1) {
    // Create a canvas
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    
    // Set canvas size (adjust as needed for text clarity)
    canvas.width = 1024;
    canvas.height = 1024;
    
    // Draw background
    context.fillStyle = '#ffffff';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Style for text
    context.fillStyle = '#000000';
    context.font = fontsize + 'px Arial';
    context.textAlign = 'left';
    
    // Text to display (paragraph text)
    // const essayText = "            We all experience adversities in life. Sometimes it's serious, like a major accident, while other times it's small things, like the struggles of everyday life. Most people in this society like to think that getting through these rough times is just a test of grit, resilience, and determination, or, in other words, our own personal character. While that might be true, we usually don't give much attention to one other important factor: luck. The truth is, a lot of people succeed not just because they worked hard, but because things happened to line up for them—perfect timing, random chances, or just pure luck. If one works hard enough, they can become successful—this is the idea that most people have about success in something. While this idea may be true, luck undeniably plays a huge role in one's success in overcoming adversity. Ultimately, while personal strength and determination help us push through tough times, factors like timing, luck, and circumstances often have a huge impact on whether we succeed or not.";
    const essayText = essayText1;
    // Word wrap function for the paragraph (without a header line)
    function wrapText(context, text, x, y, maxWidth, lineHeight) {
        const words = text.split(' ');
        let line = '';
        let lineCount = 0;
        
        for(let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' ';
            const metrics = context.measureText(testLine);
            const testWidth = metrics.width;
            
            if (testWidth > maxWidth && n > 0) {
                context.fillText(line, x, y + (lineCount * lineHeight));
                line = words[n] + ' ';
                lineCount++;
            } else {
                line = testLine;
            }
        }
        // draw last line
        context.fillText(line, x, y + (lineCount * lineHeight));
    }
    
    // Define starting positions
    const startX = 30;
    const startY = 50;
    const lineHeight = 36;
    
    // Write header "Introduction:" on its own line
    context.fillText(stareee, startX, startY);
    
    // Apply word wrapping for essayText starting on the next line
    wrapText(context, essayText, startX, startY + lineHeight + lineHeight, canvas.width - 60, lineHeight);
    
    // Use canvas as a texture
    const texture = new THREE.CanvasTexture(canvas);
    
    // Create material with the texture
    const material = new THREE.MeshBasicMaterial({ 
        map: texture,
        side: THREE.DoubleSide
    });
    
    // Create plane for the text wall
    const geometry = new THREE.PlaneGeometry(10, 10 * (canvas.height / canvas.width));
    const plane = new THREE.Mesh(geometry, material);
    
    // Position slightly in front of wall to prevent z-fighting
    plane.position.set(0, 0, -20/2 + 0.05);
    
    return plane;
}
        












// Create secret room under the map
        function createSecretRoom() {
            const roomGroup = new THREE.Group();
            
            // Room dimensions
            const roomWidth = 20;
            const roomHeight = 10;
            const roomDepth = 20;
            
            // Room walls materials
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xeeeeee, 
                side: THREE.DoubleSide,
            });

            const invisMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xeeeeee, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.0
            });
            
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(roomWidth, roomDepth);
            const floorMesh = new THREE.Mesh(floorGeometry, wallMaterial);
            floorMesh.rotation.x = -Math.PI / 2;
            floorMesh.position.y = -roomHeight/2;
            roomGroup.add(floorMesh);

            // Load the grass texture
            const sideWalkTexture = textureLoader.load('textures/sidewalk.jpg'); // Replace with your texture path

            sideWalkTexture.wrapS = THREE.RepeatWrapping;
            sideWalkTexture.wrapT = THREE.RepeatWrapping;
            sideWalkTexture.repeat.set(1, 14); // Adjust texture repeat (higher values for more repetition)

            const sideWalkMaterial = new THREE.MeshStandardMaterial({ 
                map: sideWalkTexture, 
                side: THREE.DoubleSide
            });

            // Floor
            const floorGeometry1 = new THREE.PlaneGeometry(40, 300);
            const floorMesh1 = new THREE.Mesh(floorGeometry1, sideWalkMaterial);
            floorMesh1.rotation.x = -Math.PI / 2;
            floorMesh1.position.y = -roomHeight/2 - 0.01;
            floorMesh1.position.x = 20;
            roomGroup.add(floorMesh1);

            // Load the grass texture
            const roadTexture = textureLoader.load('textures/road.jpg'); // Replace with your texture path

            roadTexture.wrapS = THREE.RepeatWrapping;
            roadTexture.wrapT = THREE.RepeatWrapping;
            roadTexture.repeat.set(12, 1); // Adjust texture repeat (higher values for more repetition)

            const roadMaterial = new THREE.MeshStandardMaterial({ 
                map: roadTexture, 
                side: THREE.DoubleSide
            });

            const roadGeometry = new THREE.PlaneGeometry(300, 20);
            const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
            roadMesh.rotation.x = -Math.PI / 2;
            roadMesh.rotation.z = Math.PI / 2;
            roadMesh.position.y = -roomHeight/2 + 0.01;
            roadMesh.position.x = 25;
            roomGroup.add(roadMesh);
            
            // Ceiling
            const ceilingMesh = new THREE.Mesh(floorGeometry, wallMaterial);
            ceilingMesh.rotation.x = Math.PI / 2;
            ceilingMesh.position.y = roomHeight/2;
            roomGroup.add(ceilingMesh);
            
            // Walls
            // Back wall (with essay)
            const backWallGeometry = new THREE.PlaneGeometry(roomWidth, roomHeight);
            const backWallMesh = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWallMesh.position.z = -roomDepth/2;
            roomGroup.add(backWallMesh);
            
            // Add back wall to collidable objects
            backWallMesh.userData.isCollidable = true;
            collidableObjects.push(backWallMesh);
            
            // Front wall
            const frontWallMesh = new THREE.Mesh(backWallGeometry, wallMaterial);
            frontWallMesh.position.z = roomDepth/2;
            frontWallMesh.rotation.y = Math.PI;
            roomGroup.add(frontWallMesh);
            
            // Add front wall to collidable objects
            frontWallMesh.userData.isCollidable = true;
            collidableObjects.push(frontWallMesh);
            
            // Left wall
            const sideWallGeometry = new THREE.PlaneGeometry(roomDepth, roomHeight);
            const leftWallMesh = new THREE.Mesh(sideWallGeometry, wallMaterial);
            leftWallMesh.position.x = -roomWidth/2;
            leftWallMesh.rotation.y = Math.PI / 2;
            roomGroup.add(leftWallMesh);
            
            // Add left wall to collidable objects
            leftWallMesh.userData.isCollidable = true;
            collidableObjects.push(leftWallMesh);
            
            // Right wall
            const rightWallMesh = new THREE.Mesh(sideWallGeometry, wallMaterial);
            rightWallMesh.position.x = roomWidth/2;
            rightWallMesh.rotation.y = -Math.PI / 2;
            roomGroup.add(rightWallMesh);
       // Add right wall to collidable objects
            rightWallMesh.userData.isCollidable = true;
            collidableObjects.push(rightWallMesh);


            // city walls

                        // Load the grass texture
            const cityTex = textureLoader.load('textures/city.jpg'); // Replace with your texture path

            cityTex.wrapS = THREE.RepeatWrapping;
            cityTex.wrapT = THREE.RepeatWrapping;
            cityTex.repeat.set(12, 1); // Adjust texture repeat (higher values for more repetition)

            const cityMat = new THREE.MeshStandardMaterial({ 
                map: cityTex, 
                side: THREE.DoubleSide,
            });

            const rightWallMesh2 = new THREE.Mesh(new THREE.PlaneGeometry(300, 30), cityMat);
            rightWallMesh2.position.x = roomWidth/2 + 0.01;
            rightWallMesh2.rotation.y = -Math.PI / 2;
            rightWallMesh2.position.y = 4;
            roomGroup.add(rightWallMesh2);
            rightWallMesh2.userData.isCollidable = true;
            collidableObjects.push(rightWallMesh2);
            rightWallMesh2.castShadow = false;
            rightWallMesh2.receiveShadow = false;

            // Right wall
            const rightWallMesh1 = new THREE.Mesh(new THREE.PlaneGeometry(300, 30), cityMat);
            rightWallMesh1.position.x = roomWidth/2 + 30;
            rightWallMesh1.rotation.y = -Math.PI / 2;
            rightWallMesh1.position.y = 4;
            roomGroup.add(rightWallMesh1);
            rightWallMesh1.castShadow = false;
            rightWallMesh1.receiveShadow = false;
            
            rightWallMesh1.userData.isCollidable = true;
            collidableObjects.push(rightWallMesh1);

            const roomLight1 = new THREE.PointLight(0xffffff, 5.5, 30);
            roomLight1.position.set(225, 5, 0);
            roomGroup.add(roomLight1);
            
            const cityText = createTextWall(36, "Gary Cohn: ", "            Gary Cohn's journey clearly illustrates how luck can significantly influence success. In Malcolm Gladwell's David and Goliath, Cohn, who struggled with dyslexia, out of the blue, hopped into a taxi with a top Wall Street executive (Gladwell, 2013, p. 121). During his taxi ride, he “[pretended] to be an experienced options trader when in fact he was not, ”(Gladwell, 2013, p. 122). Cohn ended up interviewing and getting the job, which was revolutionary for him, as a job like this was so unexpected for him. Previous to this, he was “selling aluminum siding and window frames for the U.S. Steel in Cleveland,” (Gladwell, 2013, p. 120). Gladwell in his novel pushes this story as the result of the certain strengths Cohn possessed due to his dyslexia. Although, Cohn getting into the taxi was more of a stroke of luck. On top of that, the fact that he happened to share it with a top Wall Street executive made it even more lucky. What are the chances of this happening? Not very likely. The luck runs even deeper, as the executive also happened to have started a new options business and was lacking employees. Cohn’s experience of overcoming his adversity and getting this new job was more of a moment of good luck than his personal traits, as even if he was an exceptional speaker, the timings, and opportunities were just too highly improbable.");
            cityText.position.x = 25;
            roomGroup.add(cityText);
            
        //     // Add essay introduction on the back wall
        //     const fontLoader = new THREE.FontLoader();
        //     fontLoader.load('https://cdn.jsdelivr.net/npm/three@latest/examples/fonts/helvetiker_regular.typeface.json', function(font) {
        //         const textOptions = {
        //             font: font,
        //             size: 0.25,
        //             height: 0.05,
        //             curveSegments: 12,
        //             bevelEnabled: false
        //         };
        //         const essayText = 
        // "We all experience adversities in life. Sometimes it’s serious, like a major accident, while other times it’s small things, like the struggles of everyday life. Most people in this society like to think that getting through these rough times is just a test of grit, resilience, and determination, or, in other words, our own personal character. While that might be true, we usually don't give much attention to one other important factor: luck. The truth is, a lot of people succeed not just because they worked hard, but because things happened to line up for them—perfect timing, random chances, or just pure luck. If one works hard enough, they can become successful — this is the idea that most people have about success in something. While this idea may be true, luck undeniably plays a huge role in one’s success in overcoming adversity. Ultimately, while personal strength and determination help us push through tough times, factors like timing, luck, and circumstances often have a huge impact on whether we succeed or not.";
                
        //         const textGeometry = new THREE.TextGeometry(essayText, textOptions);
        //         textGeometry.computeBoundingBox();
        //         const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
        //         textGeometry.translate(-textWidth / 2 + 12, 2, 0);
                
        //         const textMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
        //         const textMesh = new THREE.Mesh(textGeometry, textMaterial);
        //         textMesh.position.set(0, 1, -roomDepth/2 + 0.1); // Slightly in front of the wall
        //         roomGroup.add(textMesh);
        //     });
            
            // Use this in your createSecretRoom function
            const textWall = createTextWall(36, "Introduction: ", "            We all experience adversities in life. Sometimes it's serious, like a major accident, while other times it's small things, like the struggles of everyday life. Most people in this society like to think that getting through these rough times is just a test of grit, resilience, and determination, or, in other words, our own personal character. While that might be true, we usually don't give much attention to one other important factor: luck. The truth is, a lot of people succeed not just because they worked hard, but because things happened to line up for them—perfect timing, random chances, or just pure luck. If one works hard enough, they can become successful—this is the idea that most people have about success in something. While this idea may be true, luck undeniably plays a huge role in one's success in overcoming adversity. Ultimately, while personal strength and determination help us push through tough times, factors like timing, luck, and circumstances often have a huge impact on whether we succeed or not.");
            roomGroup.add(textWall);

            // Add lighting to the room
            const roomLight = new THREE.PointLight(0xffffff, 1.5, 30);
            roomLight.position.set(0, 5, 0);
            roomGroup.add(roomLight);
            
            // Position the room under the map
            roomGroup.position.set(200, 3, 0);
            scene.add(roomGroup);
            
            return roomGroup;
        }
        
        // Create the pedestal with button
        const secretButton = createPedestalAndButton();
        
        // Create the secret room
        const secretRoom = createSecretRoom();
        
        // Raycaster for button interaction and collision detection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isNearButton = false;
        let canInteract = true;
        
        // Function to teleport player to secret room
        function teleportToSecretRoom() {
            const cameraObject = controls.getObject();
            cameraObject.position.set(200, 0, 0); // Position inside the secret room
            velocity.set(0, 0, 0); // Reset velocity
        }

        // Function to teleport player back to spawn
        function teleportToSpawn() {
            const cameraObject = controls.getObject();
            cameraObject.position.set(0, 2, 0); // Position
            velocity.set(0, 0, 0); // Reset velocity
        }

        function teleportToPartTwo() {
            const cameraObject = controls.getObject();
            cameraObject.position.set(220, 2, 0); // Position
            velocity.set(0, 0, 0); // Reset velocity
            document.getElementById("toForrestPrompt").style.display = "block";
        }

        function teleportToPartFour() {
            const cameraObject = controls.getObject();
            cameraObject.position.set(-100, 2, 0); // Position
            velocity.set(0, 0, 0); // Reset velocity
            document.getElementById("toConclusion").style.display = "block";
            videoRoom.endVideo();
        }

        function teleportToPartFive() {
            const cameraObject = controls.getObject();
            cameraObject.position.set(500, 2, 0); // Position
            velocity.set(0, 0, 0); // Reset velocity
            document.getElementById("finished").style.display = "block";
        }

        
        // function teleportToPartThree() {
        //     const cameraObject = controls.getObject();
        //     cameraObject.position.set(0, 2, 0); // Position
        //     velocity.set(0, 0, 0); // Reset velocity
        // }


        // Function to create the video room at z=200
function createVideoRoom() {
    const roomGroup = new THREE.Group();
    
    // Room dimensions
    const roomWidth = 20;
    const roomHeight = 10;
    const roomDepth = 20;
    
    // Black material for the walls
    const blackMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x000000, 
        side: THREE.DoubleSide
    });
    
    // Create floor
    const floorGeometry = new THREE.PlaneGeometry(roomWidth, roomDepth);
    const floorMesh = new THREE.Mesh(floorGeometry, blackMaterial);
    floorMesh.rotation.x = -Math.PI / 2;
    floorMesh.position.y = -roomHeight/2;
    roomGroup.add(floorMesh);
    
    // Add floor to collidable objects
    floorMesh.userData.isCollidable = true;
    collidableObjects.push(floorMesh);
    
    // Create ceiling
    const ceilingMesh = new THREE.Mesh(floorGeometry, blackMaterial);
    ceilingMesh.rotation.x = Math.PI / 2;
    ceilingMesh.position.y = roomHeight/2;
    roomGroup.add(ceilingMesh);
    
    // Add ceiling to collidable objects
    ceilingMesh.userData.isCollidable = true;
    collidableObjects.push(ceilingMesh);
    
    // Create back wall (for video)
    const backWallGeometry = new THREE.PlaneGeometry(roomWidth, roomHeight);
    const backWallMesh = new THREE.Mesh(backWallGeometry, blackMaterial);
    backWallMesh.position.z = -roomDepth/2;
    roomGroup.add(backWallMesh);
    
    // Add back wall to collidable objects
    backWallMesh.userData.isCollidable = true;
    collidableObjects.push(backWallMesh);
    
    // Create front wall with entrance
    const frontWallGeometry = new THREE.PlaneGeometry(roomWidth, roomHeight);
    const frontWallMesh = new THREE.Mesh(frontWallGeometry, blackMaterial);
    frontWallMesh.position.z = roomDepth/2;
    frontWallMesh.rotation.y = Math.PI;
    roomGroup.add(frontWallMesh);
    
    // Add front wall to collidable objects
    frontWallMesh.userData.isCollidable = true;
    collidableObjects.push(frontWallMesh);
    
    // Create left wall
    const sideWallGeometry = new THREE.PlaneGeometry(roomDepth, roomHeight);
    const leftWallMesh = new THREE.Mesh(sideWallGeometry, blackMaterial);
    leftWallMesh.position.x = -roomWidth/2;
    leftWallMesh.rotation.y = Math.PI / 2;
    roomGroup.add(leftWallMesh);
    
    // Add left wall to collidable objects
    leftWallMesh.userData.isCollidable = true;
    collidableObjects.push(leftWallMesh);
    
    // Create right wall
    const rightWallMesh = new THREE.Mesh(sideWallGeometry, blackMaterial);
    rightWallMesh.position.x = roomWidth/2;
    rightWallMesh.rotation.y = -Math.PI / 2;
    roomGroup.add(rightWallMesh);
    
    // Add right wall to collidable objects
    rightWallMesh.userData.isCollidable = true;
    collidableObjects.push(rightWallMesh);
    
    // Create entrance doorway in the front wall
    const doorWidth = 4;
    const doorHeight = 7;
    const doorGeometry = new THREE.PlaneGeometry(doorWidth, doorHeight);
    const doorMesh = new THREE.Mesh(doorGeometry, blackMaterial);
    doorMesh.position.set(0, -roomHeight/2 + doorHeight/2, roomDepth/2 - 0.1);
    doorMesh.rotation.y = Math.PI;
    doorMesh.visible = false; // Make invisible to create a hole
    roomGroup.add(doorMesh);

    // create textwall thing
    const textWall = createTextWall(28, "Forrest Gump: ", "            While Gary Cohn’s story represents a key example of the importance of luck and timing in becoming successful, Forrest Gump offers another perspective on how luck plays a crucial role in overcoming adversity. Just like how Cohn had perfect timing with his encounter with the executive, Forrest’s life in the movie is shaped by random events that seem to align perfectly. This movie is an even greater example of timing and luck as throughout the entire movie, Forrest never has any intentions for what he does or what happens to him. For instance, in the movie, Forrest Gump goes shrimping on his boat during a destructive hurricane, and after the storm, his boat surprisingly was the only survivor (Zemeckis, 1994). All the other boats (which were not out at sea) had been destroyed by the storm. The only possible explanation for this was luck. He was just lucky enough to have the only surviving boat, which let him take control of the entire shrimp market of the area. Another notable example of luck in the movie is when Forrest recklessly saves his comrades in Vietnam (Zemeckis, 1994). The word reckless is key here, because Forrest had no strategies for saving his friends. He simply ran as fast as he could, saving as many soldiers as he could. After all that, he was shot only once, and it was nowhere near lethal. Recklessly running through a bombardment of enemy gunfire in the jungles of Vietnam, while carrying his comrades and not dying, was clearly just a stroke of luck.");
    textWall.position.x = 9.75;
    textWall.position.y = 0;
    textWall.position.z = 3;
    textWall.rotation.y = Math.PI / -2;
    roomGroup.add(textWall);

    
    // Create video element
    const video = document.createElement('video');
    video.src = 'textures/forrest.mp4'; // Sample video
    video.crossOrigin = 'anonymous';
    video.loop = true;
    video.muted = false;
    video.playsInline = true;
    video.style.display = 'none';
    document.body.appendChild(video);
    
    // Create video texture
    const videoTexture = new THREE.VideoTexture(video);
    videoTexture.minFilter = THREE.LinearFilter;
    videoTexture.magFilter = THREE.LinearFilter;
    
    // Create video screen
    const videoWidth = roomWidth * 0.8;
    const videoHeight = videoWidth * 9/16; // 16:9 aspect ratio
    const videoGeometry = new THREE.PlaneGeometry(videoWidth, videoHeight);
    const videoMaterial = new THREE.MeshBasicMaterial({ 
        map: videoTexture,
        side: THREE.FrontSide
    });
    
    const videoScreen = new THREE.Mesh(videoGeometry, videoMaterial);
    videoScreen.position.z = -roomDepth/2 + 0.1; // Slightly in front of back wall
    videoScreen.position.y = 0; // Center vertically
    roomGroup.add(videoScreen);
    
    // Add ambient light inside the room
    const roomAmbientLight = new THREE.AmbientLight(0x404040, 0.5);
    roomGroup.add(roomAmbientLight);
    
    // Add point light inside the room
    const roomLight = new THREE.PointLight(0xffffff, 0.8, 30);
    roomLight.position.set(0, 5, 0);
    roomGroup.add(roomLight);
    
    // Position the room
    roomGroup.position.set(0, 0, 200);
    scene.add(roomGroup);
    
    // Function to start video when player enters the room
    function startVideo() {
        if (video.paused) {
            // Try to play with user interaction
            const playPromise = video.play();
            
            if (playPromise !== undefined) {
                playPromise.then(_ => {
                    console.log("Video playback started");
                })
                .catch(error => {
                    console.error("Video playback failed:", error);
                });
            }
        }
    }

    function endVideo() {
        if (!video.paused) {
            video.pause();
        }
    }
    
    return {
        roomGroup,
        startVideo,
        endVideo
    };
}

// Create the video room
const videoRoom = createVideoRoom();

// Modify animate function to check if player is inside the video room
// Add this inside your existing animate function
function checkPlayerInVideoRoom() {
    if (controls.isLocked) {
        const playerPos = controls.getObject().position;
        const distance = Math.abs(playerPos.z - 200);
        
        // If player is close to z=200 (the video room)
        if (distance < 15) {
            videoRoom.startVideo();
        }
    }
}

// Add this call in your animate function
// checkPlayerInVideoRoom();

// Modify teleportToPartThree function to position player in front of the doorway
function teleportToPartThree() {
    const cameraObject = controls.getObject();
    cameraObject.position.set(0, 2, 205); // Position in front of the room entrance
    velocity.set(0, 0, 0); // Reset velocity

    document.getElementById("toForrestPrompt").style.display = "none";
    document.getElementById("toPersonalExample").style.display = "block";
    
    // Try to start the video immediately
    videoRoom.startVideo();
}

        // Model loading
        const modelLoader = new THREE.GLTFLoader();
        let model;

        // This URL points to a sample 3D model - you may need to use your own hosted model
        modelLoader.load(
            'models/car.glb',
            function(gltf) {
                model = gltf.scene;
                model.traverse(function(node) {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                
                // Center and scale the model
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 10 / maxDim;
                model.scale.set(scale, scale, scale);
                
                model.position.sub(center.multiplyScalar(scale));
                model.position = new THREE.Vector3(0, 0, 0); // Position model at origin
                model.position.y = -0.5; // Raise model slightly above ground
                model.position.x = 230;
                model.rotation.y = -Math.PI / 1;
                model.position.z = 50;
                scene.add(model);
            },
            function(xhr) {
                // Progress callback if needed
            },
            function(error) {
                console.error('An error happened while loading the model:', error);
            }
        );



        // Model loading
        let modelClass;

        // This URL points to a sample 3D model - you may need to use your own hosted model
        modelLoader.load(
            'models/classroom/scene.gltf',
            function(gltf) {
                modelClass = gltf.scene;
                modelClass.traverse(function(node) {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                
                // Center and scale the model
                const box = new THREE.Box3().setFromObject(modelClass);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 10 / maxDim;
                modelClass.scale.set(scale, scale, scale);
                
                modelClass.position.sub(center.multiplyScalar(scale));
                modelClass.position = new THREE.Vector3(0, 0, 0); // Position model at origin
                modelClass.position.y = 0.5; // Raise model slightly above ground
                modelClass.position.x = -100;
                modelClass.rotation.y = -Math.PI / 1;
                modelClass.position.z = 0;
                scene.add(modelClass);
            },
            function(xhr) {
                // Progress callback if needed
            },
            function(error) {
                console.error('An error happened while loading the model:', error);
            }
        );

        // create textwall for classroom
        let classTextWall = createTextWall(24, "School Testing: ", "            In the same way that Gary Cohn and Forrest Gump’s successes were shaped by timing and luck, I’ve experienced this in my own life too. One time, I had completely forgotten to study for a really important test. Well, I didn’t forget, but I’m not one to sleep late, so I simply had to sacrifice the test grade and hope that I could tank the grade. When I walked into class, however, I stood in shock as my teacher turned out to be absent! The test was automatically pushed to the next class, giving me the extra time I desperately needed. I ended up studying that night and did way better than I would’ve if the test had happened that day as planned. Just like Forrest’s boat surviving the hurricane or Cohn’s lucky taxi ride, my success in overcoming my adversity here (which was not having studied for the test) wasn’t from determination or preparation, or in fact any other character trait. It was pure luck, and if it wasn’t for my luck that day, my genesis wouldn’t be looking so hot.");
        classTextWall.position.x = -100;
        classTextWall.position.y = 1;
        classTextWall.position.z = -4.5;
        classTextWall.scale.set(0.5, 0.5, 0.5);
        scene.add(classTextWall);


        // Model loading
        let modelIsland;

        // This URL points to a sample 3D model - you may need to use your own hosted model
        modelLoader.load(
            'models/flying_island_2/scene.gltf',
            function(gltf) {
                modelIsland = gltf.scene;
                modelIsland.traverse(function(node) {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                
                // Center and scale the model
                const box = new THREE.Box3().setFromObject(modelIsland);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 75 / maxDim;
                modelIsland.scale.set(scale, scale, scale);
                
                modelIsland.position.sub(center.multiplyScalar(scale));
                modelIsland.position = new THREE.Vector3(0, 0, 0); // Position model at origin
                modelIsland.position.y = -43; // Raise model slightly above ground
                modelIsland.position.x = 500;
                modelIsland.rotation.y = -Math.PI / 1;
                // modelIsland.position.z = -300;
                scene.add(modelIsland);
            },
            function(xhr) {
                // Progress callback if needed
            },
            function(error) {
                console.error('An error happened while loading the model:', error);
            }
        );

        // create textwall for classroom
        let islandTextWall = createTextWall(42, "Conclusion:", "            Although personal strength and determination are key to overcoming adversity, factors such as timing, opportunity, and luck frequently play a crucial role in shaping success and determining outcomes. Take Gary Cohn's success for instance, he would have never been as successful as he had been if it were not for his exceptional luck that day. Him getting into the taxi with a top Wall Street executive was nothing less than a miracle in terms of luck. Then there’s Forrest Gump, who had everything seemingly work out for him, like his shrimp boat surviving the hurricane or his reckless heroism in the Vietnam War. Even my own experience shows how sometimes success isn’t just about effort, but more about luck. Life is unpredictable, and maybe that has more of an influence on our successes than we realize.");
        islandTextWall.position.x = 490;
        islandTextWall.position.y = 2.5;
        islandTextWall.position.z = 0;
        islandTextWall.rotation.y = Math.PI / 2;
        // classTextWall.scale.set(0.5, 0.5, 0.5);
        scene.add(islandTextWall);

        
        // Player physics variables
        const playerHeight = 2;
        const gravity = 0.03;
        const jumpForce = 0.4;
        const acceleration = 0.05;
        let maxSpeed = 0.1;
        const friction = 0.92; // Friction factor (lower = more friction)
        const playerRadius = 0.5; // Collision radius of the player

        // Set initial camera position
        camera.position.y = playerHeight;

        // Player physics state
        const velocity = new THREE.Vector3(0, 0, 0);
        const inputDirection = new THREE.Vector3();
        let canJump = true;
        const keys = {};

        document.addEventListener("keydown", onDocumentKeyDown, false);
        document.addEventListener("keyup", onDocumentKeyUp, false);

        let amountOfTimesTriedToGoBack = 0;

        function onDocumentKeyDown(event) {
            keys[event.key.toLowerCase()] = true;

            // Handle jump when spacebar is pressed and player can jump
            if (event.code === 'Space' && canJump && velocity.y === 0 && canStartJump) {
                velocity.y = jumpForce;
                canJump = false;
            }


            if (event.key.toLowerCase() === 'e' && canInteract && document.getElementById("toForrestPrompt").style.display === "block") {
                teleportToPartThree();
                document.getElementById("toForrestPrompt").style.display = "none";
                canInteract = false; // Prevent repeated teleportation
                canStartJump = false; // Enable jumping again
                setTimeout(() => { canInteract = true; }, 1000); // Reset after 1 second
            }

            if (event.key.toLowerCase() === 'e' && canInteract && document.getElementById("toPersonalExample").style.display === "block") {
                teleportToPartFour();
                document.getElementById("toPersonalExample").style.display = "none";
                canInteract = false; // Prevent repeated teleportation
                canStartJump = false; // Enable jumping again
                console.log("teleporting to part four")
                setTimeout(() => { canInteract = true; }, 1000); // Reset after 1 second
            }

            if (event.key.toLowerCase() === 'e' && canInteract && document.getElementById("toConclusion").style.display === "block") {
                teleportToPartFive();
                document.getElementById("toConclusion").style.display = "none";
                canInteract = false; // Prevent repeated teleportation
                canStartJump = true; // Enable jumping again
                setTimeout(() => { canInteract = true; }, 1000); // Reset after 1 second
            }
            
            // Handle interaction with button (E key)
            if (event.key.toLowerCase() === 'e' && isNearButton && canInteract) {
                teleportToSecretRoom();
                canInteract = false; // Prevent repeated teleportation
                canStartJump = false; // Disable jumping in secret room
                document.getElementById("goBackPrompt").style.display = "block";
                setTimeout(() => { canInteract = true; }, 1000); // Reset after 1 second
            }
            if (event.key.toLowerCase() === 'e' && canInteract && document.getElementById("goBackPrompt").style.display === "block") {

                if (amountOfTimesTriedToGoBack == 0){
                    document.getElementById("goBackPrompt").innerText = 'Something broke! Try pressing E again.';
                } else if (amountOfTimesTriedToGoBack == 1){
                    document.getElementById("goBackPrompt").innerText = 'Press E to generate a random number. (1-5)\nIf your number is 1 then you can go to the next place.';
                } else {
                    const randomNumber = Math.floor(Math.random() * 5) + 1;
                    if (randomNumber === 1) {
                        teleportToPartTwo();
                        document.getElementById("goBackPrompt").innerText = 'You rolled a ' + randomNumber + '!';
                        canInteract = false; // Allow interaction again
                        canStartJump = true; // Enable jumping again
                        setTimeout(() => {
                            canInteract = true;
                            document.getElementById("goBackPrompt").style.display = "none";
                        }, 1000); // Reset after 1 second
                    } else {
                        document.getElementById("goBackPrompt").innerText = 'You rolled a ' + randomNumber + '. Try again! (press E)';
                    }
                }
                amountOfTimesTriedToGoBack++;
                // teleportToSpawn();
                // document.getElementById("goBackPrompt").style.display = "none";
                // canInteract = false; // Prevent repeated teleportation
                // canStartJump = true; // Disable jumping in secret room
                // setTimeout(() => { canInteract = true; }, 1000); // Reset after 1 second
            }
        }

        function onDocumentKeyUp(event) {
            keys[event.key.toLowerCase()] = false;
        }

        // Check if moving in a direction would cause a collision
        function checkCollision(position, direction, distance) {
            // Create the raycaster from the player's position in the direction of movement
            raycaster.set(position, direction.normalize());
            
            // Check for intersections with collidable objects
            const intersections = raycaster.intersectObjects(collidableObjects);
            
            // If there's an intersection within the distance, collision detected
            return intersections.length > 0 && intersections[0].distance < distance;
        }

        // Get time for consistent physics regardless of framerate
        let prevTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            
            if(started) {
                // Calculate delta time for frame-rate independent physics
                const time = performance.now();
                const delta = (time - prevTime) / 1000; // Convert to seconds
                prevTime = time;
                
                model.position.z += -30 * delta; // Move the model forward slowly
                if (model.position.z < -60) {
                    model.position.z = 60;
                }

                // Apply physics only if controls are locked
                if (controls.isLocked) {
                    // Reset input direction
                    inputDirection.set(0, 0, 0);

                    // Get movement direction from key presses
                    if (keys["w"]) inputDirection.z = 1;
                    if (keys["s"]) inputDirection.z = -1;
                    if (keys["a"]) inputDirection.x = 1;
                    if (keys["d"]) inputDirection.x = -1;
                    
                    if (keys["shift"]) maxSpeed = 0.2; // Sprinting speed
                    else maxSpeed = 0.1; // Normal speed

                    // Normalize input direction to prevent diagonal speed boost
                    if (inputDirection.length() > 0) {
                        inputDirection.normalize();
                    }

                    // Get camera direction vectors
                    const cameraObject = controls.getObject();
                    const cameraDirection = new THREE.Vector3();
                    cameraObject.getWorldDirection(cameraDirection);
                    
                    // Calculate forward and right vectors (relative to camera orientation)
                    // We only want horizontal movement, so we zero out the Y component and renormalize
                    cameraDirection.y = 0;
                    cameraDirection.normalize();
                    
                    // Calculate right vector (perpendicular to forward vector and up)
                    const rightVector = new THREE.Vector3();
                    rightVector.crossVectors(new THREE.Vector3(0, 1, 0), cameraDirection).normalize();
                    
                    // Calculate movement vector based on input and camera orientation
                    const moveX = rightVector.clone().multiplyScalar(inputDirection.x);
                    const moveZ = cameraDirection.clone().multiplyScalar(inputDirection.z);
                    
                    // Combined movement direction (camera-relative)
                    const moveDirection = new THREE.Vector3().addVectors(moveX, moveZ);
                    
                    // Apply acceleration in the direction the player is trying to move
                    if (moveDirection.length() > 0) {
                        velocity.x += moveDirection.x * acceleration * delta * 60;
                        velocity.z += moveDirection.z * acceleration * delta * 60;
                    }

                    // Apply friction
                    velocity.x *= friction;
                    velocity.z *= friction;

                    // Limit maximum horizontal speed
                    const horizontalSpeed = Math.sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
                    if (horizontalSpeed > maxSpeed) {
                        const ratio = maxSpeed / horizontalSpeed;
                        velocity.x *= ratio;
                        velocity.z *= ratio;
                    }

                    // Apply gravity
                    velocity.y -= gravity * delta * 60; // Scale with delta time and normalize to 60fps

                    // Store original position for collision restoration
                    const originalPosition = cameraObject.position.clone();
                    
                    // Calculate new position
                    const newPosition = originalPosition.clone();
                    newPosition.x += velocity.x;
                    newPosition.z += velocity.z;
                    
                    // Check for horizontal collisions in X direction
                    if (velocity.x !== 0) {
                        const directionX = new THREE.Vector3(velocity.x > 0 ? 1 : -1, 0, 0);
                        if (checkCollision(originalPosition, directionX, playerRadius + Math.abs(velocity.x))) {
                            velocity.x = 0; // Stop movement in X direction
                        }
                    }
                    
                    // Check for horizontal collisions in Z direction
                    if (velocity.z !== 0) {
                        const directionZ = new THREE.Vector3(0, 0, velocity.z > 0 ? 1 : -1);
                        if (checkCollision(originalPosition, directionZ, playerRadius + Math.abs(velocity.z))) {
                            velocity.z = 0; // Stop movement in Z direction
                        }
                    }
                    
                    // Move the player based on velocity (after collision checks)
                    cameraObject.position.x += velocity.x;
                    cameraObject.position.z += velocity.z;
                    cameraObject.position.y += velocity.y;

                    // Check for floor collision
                    if (cameraObject.position.y < playerHeight) {
                        velocity.y = 0;
                        cameraObject.position.y = playerHeight;
                        canJump = true; // Allow jumping again when on the ground
                    }
                    
                    // Check if player is near the button
                    // Create a vector pointing from camera to button
                    const playerPos = cameraObject.position.clone();
                    const buttonPos = new THREE.Vector3(0, 1, -10); // Button position
                    const distance = playerPos.distanceTo(buttonPos);
                    
                    // If player is within 3 units of the button, show interaction prompt
                    if (distance < 3) {
                        isNearButton = true;
                        document.getElementById("interactPrompt").style.display = "block";
                    } else {
                        isNearButton = false;
                        document.getElementById("interactPrompt").style.display = "none";
                    }
                }
            }

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>